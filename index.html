<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>Golf Swing Composite — v2.4 (Equal-Checker Merge, No Base)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --box-w: min(80vw, 1000px); }
    body { margin:0; background:#000; color:#fff; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
    #version{ position:absolute; top:12px; right:12px; opacity:.85; font:600 12px/1 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
    #status { position:absolute; top:12px; left:12px; background:rgba(255,255,255,.08); padding:6px 10px; border-radius:8px; font-size:14px; }
    #feedWrap{ position:absolute; inset:0; display:grid; place-items:center; }
    #feedCanvas{ width:var(--box-w); aspect-ratio:4/3; border:2px solid #fff; background:#000; display:block; }
    #videoEl{ display:none; }
    #controls{ position:absolute; left:0; right:0; bottom:18px; display:flex; flex-direction:column; align-items:center; gap:10px; }
    .row{ display:flex; gap:18px; flex-wrap:wrap; justify-content:center; }
    button{ cursor:pointer; font-size:16px; }
    #startBtn{ width:110px; height:110px; border-radius:50%; background:#e10000; color:#fff; border:4px solid #fff; font-weight:700; }
    #resetBtn, #saveBtn { padding:10px 14px; border-radius:10px; background:#111; border:1px solid #555; color:#fff; }
    label{ font-size:14px; color:#ddd; display:flex; align-items:center; gap:8px; }
    select{ appearance:none; background:#111; color:#fff; border:1px solid #555; border-radius:8px; padding:8px 10px; font-size:14px; min-width:130px; }
  </style>
</head>
<body>
  <div id="version">v2.4</div>
  <div id="status">Loading…</div>

  <!-- Hidden camera source -->
  <video id="videoEl" autoplay playsinline muted></video>

  <!-- Centered canvas: shows live (pre-capture) and the checker composite -->
  <div id="feedWrap"><canvas id="feedCanvas"></canvas></div>

  <!-- Controls -->
  <div id="controls">
    <div class="row">
      <button id="startBtn">Start</button>
      <button id="resetBtn">Reset</button>
      <button id="saveBtn">Save</button>
    </div>
    <div class="row">
      <label>Interval
        <select id="interval">
          <option value="50">0.05s</option>
          <option value="100">0.10s</option>
          <option value="200" selected>0.20s</option>
          <option value="300">0.30s</option>
          <option value="400">0.40s</option>
          <option value="500">0.50s</option>
          <option value="1000">1.00s</option>
        </select>
      </label>
    </div>
  </div>

  <script>
    // ====== Tunables ======
    const TILE_PX = 4;               // checker tile size in pixels (smaller => finer mix)
    const TARGET_LONG_EDGE = 1920;   // aim ~1080p long edge (falls back to 1280/640 if camera lower)
    const PREVIEW_SMOOTHING = true;  // nicer preview scaling

    // ====== Elements ======
    const videoEl    = document.getElementById('videoEl');
    const feedCanvas = document.getElementById('feedCanvas');
    const statusEl   = document.getElementById('status');
    const startBtn   = document.getElementById('startBtn');
    const resetBtn   = document.getElementById('resetBtn');
    const saveBtn    = document.getElementById('saveBtn');
    const intSel     = document.getElementById('interval');

    // Offscreen capture canvas (same size as feedCanvas pixels)
    const frameCanvas = document.createElement('canvas');
    const fctx        = frameCanvas.getContext('2d', { willReadFrequently:true });

    // Visible canvas context
    const cctx        = feedCanvas.getContext('2d', { willReadFrequently:true });

    // State
    let stream=null, previewRAF=null, capturing=false, timer=null;
    let frames = [];          // array of offscreen canvases (one per captured frame)
    let tilesX=0, tilesY=0, tileCount=0, perm=null; // permutation for uniform tile distribution

    // ====== Helpers ======
    function pickTargetMax(vw, vh) {
      const m = Math.max(vw, vh);
      if (m >= 1920) return 1920;
      if (m >= 1280) return 1280;
      return 640;
    }

    function initCanvasSizes() {
      const vw = videoEl.videoWidth|0, vh = videoEl.videoHeight|0;
      if (!vw || !vh) return false;
      const target = Math.min(TARGET_LONG_EDGE, pickTargetMax(vw,vh));
      const scale  = target / Math.max(vw, vh);
      const cw = Math.max(1, Math.round(vw * scale));
      const ch = Math.max(1, Math.round(vh * scale));
      if (feedCanvas.width !== cw || feedCanvas.height !== ch) {
        feedCanvas.width = cw; feedCanvas.height = ch;
        frameCanvas.width = cw; frameCanvas.height = ch;

        // compute tile grid
        tilesX = Math.ceil(cw / TILE_PX);
        tilesY = Math.ceil(ch / TILE_PX);
        tileCount = tilesX * tilesY;

        // precompute a random permutation of tile indices (for nice spatial mixing)
        perm = new Uint32Array(tileCount);
        for (let i=0;i<tileCount;i++) perm[i]=i;
        // Fisher–Yates shuffle
        for (let i=tileCount-1;i>0;i--) {
          const j = (Math.random() * (i+1)) | 0;
          const t = perm[i]; perm[i] = perm[j]; perm[j] = t;
        }
      }
      return true;
    }

    function drawPreview() {
      cancelAnimationFrame(previewRAF);
      const tick = () => {
        const vw = videoEl.videoWidth|0, vh = videoEl.videoHeight|0;
        if (vw && vh) {
          initCanvasSizes();
          if (PREVIEW_SMOOTHING) {
            cctx.imageSmoothingEnabled = true;
            cctx.imageSmoothingQuality = 'high';
          }
          cctx.globalAlpha = 1;
          cctx.globalCompositeOperation = 'source-over';
          cctx.drawImage(videoEl, 0, 0, feedCanvas.width, feedCanvas.height);
        }
        previewRAF = requestAnimationFrame(tick);
      };
      previewRAF = requestAnimationFrame(tick);
    }

    function grabFrame() {
      // draw current video frame into frameCanvas at composite size
      fctx.globalAlpha = 1;
      fctx.globalCompositeOperation = 'source-over';
      fctx.drawImage(videoEl, 0, 0, frameCanvas.width, frameCanvas.height);

      // store snapshot as its own offscreen canvas (so it doesn't change)
      const snap = document.createElement('canvas');
      snap.width = frameCanvas.width; snap.height = frameCanvas.height;
      snap.getContext('2d').drawImage(frameCanvas, 0, 0);
      frames.push(snap);
    }

    function recompositeChecker() {
      // Equal distribution: for each tile, pick frame = perm[tile] % frames.length
      const F = frames.length;
      if (!F) return;

      const cw = feedCanvas.width, ch = feedCanvas.height;
      cctx.clearRect(0,0,cw,ch);

      for (let ty=0; ty<tilesY; ty++) {
        for (let tx=0; tx<tilesX; tx++) {
          const tileIndex = ty*tilesX + tx;
          const bucket = perm[tileIndex] % F; // ensures near-equal usage of frames
          const src = frames[bucket];

          const sx = tx * TILE_PX, sy = ty * TILE_PX;
          const sw = Math.min(TILE_PX, cw - sx);
          const sh = Math.min(TILE_PX, ch - sy);

          // copy that tile from the chosen frame into the composite
          cctx.drawImage(src, sx, sy, sw, sh, sx, sy, sw, sh);
        }
      }
    }

    function resetAll() {
      try { if (previewRAF) cancelAnimationFrame(previewRAF); } catch {}
      try { if (timer) clearInterval(timer); } catch {}
      previewRAF=null; timer=null; capturing=false;
      frames.length = 0;
      cctx.clearRect(0,0,feedCanvas.width,feedCanvas.height);
      drawPreview();
      statusEl.textContent = 'Reset — ready';
      startBtn.textContent = 'Start';
      startBtn.style.background = '#e10000';
    }

    function savePNG() {
      const url = feedCanvas.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = url; a.download = 'composite-v2.4.png';
      document.body.appendChild(a); a.click(); a.remove();
    }

    // ====== Camera init (prefer rear) ======
    (async function initCamera(){
      statusEl.textContent = 'Requesting camera…';
      const tries = [
        { video:{ facingMode:{ exact:'environment' } }, audio:false },
        { video:{ facingMode:{ ideal:'environment' } }, audio:false },
        { video:{ facingMode:{ ideal:'user' } }, audio:false },
        { video:true, audio:false }
      ];
      let ok=false;
      for (const c of tries) { try { stream = await navigator.mediaDevices.getUserMedia(c); ok=true; break; } catch {} }
      if (!ok) { statusEl.textContent = 'Camera blocked/unavailable'; return; }
      videoEl.srcObject = stream; try { await videoEl.play(); } catch {}
      statusEl.textContent = 'Camera ready — press Start';
      drawPreview();
    })();

    // ====== Start/Stop capture ======
    startBtn.addEventListener('click', () => {
      if (!stream) return;

      if (!capturing) {
        // START
        capturing = true;
        startBtn.textContent = 'Stop';
        startBtn.style.background = '#b00000';
        // stop preview so we only see the composite as it builds
        try { cancelAnimationFrame(previewRAF); } catch {} previewRAF=null;

        // ensure canvases sized
        if (!initCanvasSizes()) return;

        const intervalMs = Math.max(10, parseInt(intSel.value || '200', 10));
        timer = setInterval(() => {
          grabFrame();
          recompositeChecker();
          statusEl.textContent = `Frames: ${frames.length} — checker equal mix`;
        }, intervalMs);

      } else {
        // STOP
        capturing = false;
        startBtn.textContent = 'Start';
        startBtn.style.background = '#e10000';
        if (timer) { clearInterval(timer); timer=null; }
        statusEl.textContent = `Stopped — ${frames.length} frame(s) mixed equally`;
      }
    });

    resetBtn.addEventListener('click', resetAll);
    saveBtn.addEventListener('click', savePNG);

    // Cleanup on unload
    window.addEventListener('beforeunload', () => {
      try { if (previewRAF) cancelAnimationFrame(previewRAF); } catch {}
      try { if (timer) clearInterval(timer); } catch {}
      try {
        if (stream) {
          const tracks = stream.getTracks ? stream.getTracks() : [];
          tracks.forEach(t => { try { t.stop(); } catch {} });
        }
      } catch {}
    });
  </script>
</body>
</html>
